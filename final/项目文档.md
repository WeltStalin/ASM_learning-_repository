

#  伪图形化界面工具复刻与使用测试

## 功能介绍

​	在我们大一的时候，我们学习了《高级语言程序设计》这门课，其中我们需要完成几个大项目，包括“汉诺塔”以及“消灭星星”。这其中就使用到了一种叫做伪图形化界面的东西，它的实现原理是通过直接调用Windows的API，从而实现创建一个大小可控的窗口，并且可以在其中不同的地点绘制不同的色块、图形、符号，从而可以实现通过命令行的方式模拟显示出图形化的交互界面。

​	而本次项目的功能就是利用汇编的方式来实现这些伪图形化的库函数，从而便于我们使用汇编开发时的UI界面优化。同时我也在复刻完成伪图形化界面库之后，用汇编显示了“汉诺塔”程序的部分伪图形化界面功能，验证了该库的可用性。



## 开发流程

1、寻找到当时所使用的伪图形化界面的代码库

2、根据代码库查看源码试图理解其实现原理

3、搜索寻找用汇编实现流程当中所需要的功能的方法

4、编写汇编代码并进行简单测试其功能效果

5、用生成的库函数实现汉诺塔的图像生成



## 开发心得

1、汇编代码量大起来之后阅读起来真的十分困难。对于C语言而言，一个函数的声明只需要一行代码就可以将它的函数名、返回值与形参全部声明完成，接下来只需要专注于其实现过程即可；然而对于汇编语言而言，它需要包括现场保存部分、参数传递部分、函数体部分与现场恢复部分，一个在C语言里很简短的函数，在汇编里写出来就非常的繁琐，而且，对于现场的保存与恢复还必须要注重其顺序，一旦顺序出现问题就很可能导致程序跑飞，出现不可预知的错误。之一系列的原因都导致汇编程序的开发十分的困难，尤其是当我后来在尝试利用汇编来实现汉诺塔的图形化展示时。并且，由于内容十分底层，很多赋值内容都十分抽象，所以很多功能在实现的过程当中都需要临时查找资料才能确定作用。

2、在C/C++等高级语言中，开发者可以利用丰富的库函数来简化代码编写，提高开发效率。例如，字符串处理、数学计算等功能都可以通过调用库函数来实现。相比之下，汇编的库函数资源可以说是相当的匮乏，大多数情况下，我需要自己编写底层代码来实现这些功能，这无疑增加了开发的工作量和复杂度。尤其是在处理各种输入输出时，汇编语言的这一局限性更加明显。

3、在汇编语言的开发过程中，位对齐和现场保存与恢复是非常重要的考虑因素。位对齐涉及到数据在内存中的存储方式，不正确的对齐直接就会导致程序报错，无法运行。最经典的就是8位寄存器与16位寄存器之间的操作，如果不进行特殊处理，往往会带来意想不到的bug。

4、现场保存与恢复也十分重要，平时在写C++等语言的代码时，这一工作已经被编译器自动进行了，我们无需操心。然而在编写汇编程序的时候，这件事就变成我需要重点关注的问题了。尤其是当程序复杂度逐渐提升，函数之间的嵌套调用层数越高，带来的影响就越明显。经常出现一些因为现场保存和回复操作不当所出现的bug，而且这种bug还非常难被察觉到，在排查时往往会花费大量的时间。此外，栈空间的大小也需要仔细管理，像汉诺塔这种需要通过递归调用来解决问题的情况十分容易因为占空间分配不当而导致栈溢出或栈空间不足，同样会导致程序出现难以察觉的错误。

5、汇编语言中特别容易出现死循环，这是因为汇编语言对控制流的控制非常直接和底层。在高级语言中，循环通常通过简单的循环结构来实现，而在汇编语言中，开发者需要手动管理循环的每一个步骤，包括条件判断和跳转指令。这增加了编写错误和逻辑错误的风险，尤其是在复杂的循环逻辑中，往往会出现变量更新不及时、判断条件写错、甚至循环变量被意外修改。由于汇编环境下，寄存器的功能往往是多种多样的，如果在循环内部不小心修改了和循环次数相关的变量，那么有极大概率会导致死循环的出现。

6、当汇编代码被分包后，链接过程会变得十分繁琐。这是因为汇编语言的链接不仅仅涉及到代码的合并，还包括对各个模块中符号的解析和地址的调整。在需要反复debug的情况下，这个过程可能会变得非常耗时和复杂，因为每次代码的更改都可能需要重新进行链接和调试，在高级语言的编译器当中，我们往往只需要在修改好代码之后按一个快捷键就可以一键重新生成新的可执行文件，而汇编这里则需要一步一步重头开始，包括磁盘虚拟化挂载、汇编、链接、生成等繁琐的重复性动作。

7、调试汇编代码时，由于缺乏高级语言的抽象层次，调试器提供的信息往往不如C/C++等语言那样直观。我在调试的过程当中往往会感觉到非常的麻烦，因为很多时候要一个一个去对比寄存器的值，同时还要翻资料去确认每一个寄存器里的值是否正常，分别都代表着什么意思，这为程序的debug带来了巨大的挑战。

需要对寄存器、内存地址和指令流有更深入的理解，才能有效地使用调试工具。这不仅要求开发者具备较强的汇编语言知识，还需要对硬件架构有深入的了解。

8、汇编语言的代码维护成本高。随着时间的推移，汇编代码的可读性和可维护性会逐渐降低，这不仅仅是因为汇编语言过于底层，导致需要实现的函数非常多，同时也因为其每一个模块的长度都比高级语言代码长得多，实际的操作也更加的抽象，难以被直观地理解。